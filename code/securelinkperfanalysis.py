# -*- coding: utf-8 -*-
"""Análise e desempenho - joão Paulo Nobre Rodrigues.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zuvnyHV9FNfbHEmo7hrnkgua9KdtvUq_
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats
#CSVs
df_ipsec = pd.read_csv('/content/drive/MyDrive/FACULDADE/Semestre 2023.2/Análise e desempenho em redes de computadores/Datasets/ipsec.csv')
df_tls = pd.read_csv('/content/drive/MyDrive/FACULDADE/Semestre 2023.2/Análise e desempenho em redes de computadores/Datasets/tls.csv')

"""
# Métricas"""

# 1. Taxa de Transferência Efetiva.
# 2. Taxa de Bits.
# 3. Perda de Pacotes de Túnel.
# 4. Taxa de Erros e Retransmissões
# 5. Congestion Window
# 5. Latência

"""
# Taxa de Transferência Efetiva"""

transferenciaEfetivaIPsec = round(((df_ipsec['Transfer(MB)'].sum()) / 600) * 8, 2)
transferenciaEfetivaTLS = round(((df_tls['Transfer(MB)'].sum()) / 600) * 8, 2)
print(transferenciaEfetivaIPsec, transferenciaEfetivaTLS)

# Gráfico
taxaTranferenciaEfetiva = [transferenciaEfetivaIPsec, transferenciaEfetivaTLS]
protocolos = ["IPsec", "TLS"]

plt.bar(protocolos, taxaTranferenciaEfetiva, color=['blue', 'orange'])
plt.title('Taxa de Transferência Efetiva Média para IPsec e TLS')
plt.ylabel('Taxa de Transferência (Mbps)')
plt.show()

"""# Taxa de Bits"""

taxaBitsIPsec = round(df_ipsec['Bitrate(MB)'].mean(), 2)
taxaBitsTLS = round(df_tls['Bitrate(MB)'].mean(), 2)
print(f"IPsec: {round(taxaBitsIPsec,2)}MB/s")
print(f"TLS: {round(taxaBitsTLS,2)}MB/s")

# Gráfico
taxas_bits = [taxaBitsIPsec, taxaBitsTLS]
plt.bar(protocolos, taxas_bits, color=['blue', 'orange'])
plt.title('Taxa Média de Bits para IPsec e TLS')
plt.ylabel('Taxa de Bits (MB/s)')
plt.show()

"""# Retransmissões"""

retransmissoesIPsec = df_ipsec['Retr'].sum()
retransmissoesTLS = df_tls['Retr'].sum()
print(f"IPsec: {retransmissoesIPsec}")
print(f"TLS: {retransmissoesTLS}")

# Gráficos

retransmissoes = [retransmissoesIPsec, retransmissoesTLS]

plt.bar(protocolos, retransmissoes, color=['blue', 'orange'])
plt.title('Retransmissões IPsec e TLS')
plt.ylabel('Número de Pacotes Retransmitidos')
plt.show()

"""# Taxa de Erros"""

tranferenciaTotalIPsec = df_ipsec['Transfer(MB)'].sum()
pacotesEnviadosIPsec = ( tranferenciaTotalIPsec / 0.128)
taxaPerdaPacotesIpsec = (retransmissoesIPsec / pacotesEnviadosIPsec) * 100
print(f"IPsec: {round(taxaPerdaPacotesIpsec, 2)}%")

tranferenciaTotalTLS = df_tls['Transfer(MB)'].sum()
pacotesEnviadosTLS = ( tranferenciaTotalTLS / 0.128)
taxaPerdaPacotesTLS = (retransmissoesTLS / pacotesEnviadosTLS) * 100
print(f"TLS: {round(taxaPerdaPacotesTLS, 2)}%")

# Gráfico
taxaErros = [taxaPerdaPacotesIpsec, taxaPerdaPacotesTLS]
plt.bar(protocolos, taxaErros, color='red', label='Taxa de Erros')
plt.bar(protocolos, retransmissoes, bottom=taxaErros, color=['blue', 'orange'], label='')

plt.title('Taxa de Erros para IPsec e TLS')
plt.ylabel('Retransmissões')
plt.legend()
plt.show()

"""# Janela de Congestionamento"""

mediaJanelaCongestionamentoIPsec = round(df_ipsec['Cwnd(KB)'].mean(), 3)
mediaJanelaCongestionamentoTls = round(df_tls['Cwnd(KB)'].mean(), 3)

janelas  = [mediaJanelaCongestionamentoIPsec, mediaJanelaCongestionamentoTls]

plt.bar(protocolos, janelas, color=['blue', 'orange'])
plt.title('Média das janelas de congestionamento de cada túnel')
plt.ylabel('Tamanho(KB)')
plt.show()

print(f"IPsec: {mediaJanelaCongestionamentoIPsec}\nTLS: {mediaJanelaCongestionamentoTls}")

"""# Latência"""

mediaLatenciaIPsec = df_ipsec['RTT'].mean()
mediaLatenciaTLS = df_tls['RTT'].mean()

taxas_latencia = [mediaLatenciaIPsec, mediaLatenciaTLS]
protocolos_bits = ['IPsec', 'TLS']
print(f"IPsec: {mediaLatenciaIPsec}\nTLS: {mediaLatenciaTLS}")


plt.bar(protocolos_bits, taxas_latencia, color=['blue', 'orange'])
plt.title('Taxa Média de Latência para IPsec e TLS')
plt.ylabel('Tempo(ms)')
plt.show()

"""# Variâncias"""

# IPsec

varianciaTransferIPsec = np.var(df_ipsec['Transfer(MB)'])

varianciaBitrateIPsec = np.var(df_ipsec['Bitrate(MB)'])

varianciaJanelaIPsec = np.var(df_ipsec['Cwnd(KB)'])

varianciaLatenciaIPsec = np.var(df_ipsec['RTT'])

# TLS

varianciaTransferTLS = np.var(df_tls['Transfer(MB)'])

varianciaBitrateTLS = np.var(df_tls['Bitrate(MB)'])

varianciaJanelaTLS = np.var(df_tls['Cwnd(KB)'])

varianciaLatenciaTLS = np.var(df_tls['RTT'])


print("IPsec:")
print(f"Transferência: {varianciaTransferIPsec}")
print(f"Bitrate: {varianciaBitrateIPsec}")
print(f"Janela: {varianciaJanelaIPsec}")
print(f"Latência: {varianciaLatenciaIPsec}")

print("\nTLS:")
print(f"Transferência: {varianciaTransferTLS}")
print(f"Bitrate: {varianciaBitrateTLS}")
print(f"Janela: {varianciaJanelaTLS}")
print(f"Latência: {varianciaLatenciaTLS}")

# Criar dados fictícios para o exemplo
dados_1 = df_ipsec['Transfer(MB)']
dados_2 = df_tls['Transfer(MB)']

# Criar uma lista de dados para o boxplot
dados = [dados_1, dados_2]

# Calcular a variância para cada conjunto de dados
variancias = [np.var(dado) for dado in dados]

# Criar o gráfico de boxplot
plt.boxplot(dados)

# Adicionar marcadores para a variância
for i, variancia in enumerate(variancias):
    plt.text(i + 1, max(dados[i]) + 0.2, f'Var: {variancia:.2f}', ha='center', va='center', color='red')

# Adicionar rótulos aos eixos
plt.xlabel('Grupos')
plt.ylabel('Valores')

# Adicionar rótulos aos ticks do eixo x
plt.xticks([1, 2], ['IPsec', 'TLS'])

# Adicionar título ao gráfico
plt.title('Boxplot com Variância')

# Exibir o gráfico
plt.show()

# Criar dados fictícios para o exemplo
dados_1 = df_ipsec['Bitrate(MB)']
dados_2 = df_tls['Bitrate(MB)']

# Criar uma lista de dados para o boxplot
dados = [dados_1, dados_2]

# Calcular a variância para cada conjunto de dados
variancias = [np.var(dado) for dado in dados]

# Criar o gráfico de boxplot
plt.boxplot(dados)

# Adicionar marcadores para a variância
for i, variancia in enumerate(variancias):
    plt.text(i + 1, max(dados[i]) + 0.2, f'Var: {variancia:.2f}', ha='center', va='center', color='red')

# Adicionar rótulos aos eixos
plt.xlabel('Grupos')
plt.ylabel('Valores')

# Adicionar rótulos aos ticks do eixo x
plt.xticks([1, 2], ['IPsec', 'TLS'])

# Adicionar título ao gráfico
plt.title('Boxplot com Variância')

# Exibir o gráfico
plt.show()

# Criar dados fictícios para o exemplo
dados_1 = df_ipsec['RTT']
dados_2 = df_tls['RTT']

# Criar uma lista de dados para o boxplot
dados = [dados_1, dados_2]

# Calcular a variância para cada conjunto de dados
variancias = [np.var(dado) for dado in dados]

# Criar o gráfico de boxplot
plt.boxplot(dados)

# Adicionar marcadores para a variância
for i, variancia in enumerate(variancias):
    plt.text(i + 1, max(dados[i]) + 0.2, f'Var: {variancia:.2f}', ha='center', va='center', color='red')

# Adicionar rótulos aos eixos
plt.xlabel('Grupos')
plt.ylabel('Valores')

# Adicionar rótulos aos ticks do eixo x
plt.xticks([1, 2], ['IPsec', 'TLS'])

# Adicionar título ao gráfico
plt.title('Boxplot com Variância')

# Exibir o gráfico
plt.show()

# Criar dados fictícios para o exemplo
dados_1 = df_ipsec['Cwnd(KB)']
dados_2 = df_tls['Cwnd(KB)']

# Criar uma lista de dados para o boxplot
dados = [dados_1, dados_2]

# Calcular a variância para cada conjunto de dados
variancias = [np.var(dado) for dado in dados]

# Cores para os boxplots
cores = ['skyblue', 'lightcoral']

# Criar o gráfico de boxplot com cores personalizadas
fig, ax = plt.subplots()
bp = ax.boxplot(dados, patch_artist=True, notch=True, vert=0, widths=0.6)

# Adicionar cores aos boxplots
for box, cor in zip(bp['boxes'], cores):
    box.set(facecolor=cor, alpha=0.7)

# Adicionar marcadores para a variância na borda do gráfico
for i, variancia in enumerate(variancias):
    plt.text(max(max(dados[i]) + 1, 0.5), i + 1, f'Var: {variancia:.2f}', ha='left', va='center', color='red')

# Adicionar rótulos aos eixos
ax.set_yticklabels(['IPsec', 'TLS'])
ax.set_xlabel('Valores')

# Adicionar título ao gráfico
plt.title('Variância Janela de Congestionamento')

# Ajustar a margem direita para acomodar os rótulos
plt.subplots_adjust(right=1)

# Exibir o gráfico
plt.show()

# Criar dados fictícios para o exemplo
dados_1 = df_ipsec['RTT']
dados_2 = df_tls['RTT']

# Criar uma lista de dados para o boxplot
dados = [dados_1, dados_2]

# Calcular a variância para cada conjunto de dados
variancias = [np.var(dado) for dado in dados]

# Cores para os boxplots
cores = ['skyblue', 'lightcoral']

# Criar o gráfico de boxplot com cores personalizadas
fig, ax = plt.subplots()
bp = ax.boxplot(dados, patch_artist=True, notch=True, vert=0, widths=0.6)

# Adicionar cores aos boxplots
for box, cor in zip(bp['boxes'], cores):
    box.set(facecolor=cor, alpha=0.7)

# Adicionar marcadores para a variância na borda do gráfico
for i, variancia in enumerate(variancias):
    plt.text(max(max(dados[i]) + 1, 0.5), i + 1, f'Var: {variancia:.2f}', ha='left', va='center', color='red')

# Adicionar rótulos aos eixos
ax.set_yticklabels(['IPsec', 'TLS'])
ax.set_xlabel('Valores')

# Adicionar título ao gráfico
plt.title('Variância Latência')

# Ajustar a margem direita para acomodar os rótulos
plt.subplots_adjust(right=1)

# Exibir o gráfico
plt.show()

# Criar dados fictícios para o exemplo
dados_1 = df_ipsec['Bitrate(MB)']
dados_2 = df_tls['Bitrate(MB)']

# Criar uma lista de dados para o boxplot
dados = [dados_1, dados_2]

# Calcular a variância para cada conjunto de dados
variancias = [np.var(dado) for dado in dados]

# Cores para os boxplots
cores = ['skyblue', 'lightcoral']

# Criar o gráfico de boxplot com cores personalizadas
fig, ax = plt.subplots()
bp = ax.boxplot(dados, patch_artist=True, notch=True, vert=0, widths=0.6)

# Adicionar cores aos boxplots
for box, cor in zip(bp['boxes'], cores):
    box.set(facecolor=cor, alpha=0.7)

# Adicionar marcadores para a variância na borda do gráfico
for i, variancia in enumerate(variancias):
    plt.text(max(max(dados[i]) + 1, 0.5), i + 1, f'Var: {variancia:.2f}', ha='left', va='center', color='red')

# Adicionar rótulos aos eixos
ax.set_yticklabels(['IPsec', 'TLS'])
ax.set_xlabel('Valores')

# Adicionar título ao gráfico
plt.title('Variância Bitrate')

# Ajustar a margem direita para acomodar os rótulos
plt.subplots_adjust(right=1)

# Exibir o gráfico
plt.show()

# Criar dados fictícios para o exemplo
dados_1 = df_ipsec['Transfer(MB)']
dados_2 = df_tls['Transfer(MB)']

# Criar uma lista de dados para o boxplot
dados = [dados_1, dados_2]

# Calcular a variância para cada conjunto de dados
variancias = [np.var(dado) for dado in dados]

# Cores para os boxplots
cores = ['skyblue', 'lightcoral']

# Criar o gráfico de boxplot com cores personalizadas
fig, ax = plt.subplots()
bp = ax.boxplot(dados, patch_artist=True, notch=True, vert=0, widths=0.6)

# Adicionar cores aos boxplots
for box, cor in zip(bp['boxes'], cores):
    box.set(facecolor=cor, alpha=0.7)

# Adicionar marcadores para a variância na borda do gráfico
for i, variancia in enumerate(variancias):
    plt.text(max(max(dados[i]) + 1, 0.5), i + 1, f'Var: {variancia:.2f}', ha='left', va='center', color='red')

# Adicionar rótulos aos eixos
ax.set_yticklabels(['IPsec', 'TLS'])
ax.set_xlabel('Valores')

# Adicionar título ao gráfico
plt.title('Variância Transfer')

# Ajustar a margem direita para acomodar os rótulos
plt.subplots_adjust(right=1)

# Exibir o gráfico
plt.show()

"""# Teste de Hipótese"""

from scipy.stats import ttest_ind, mannwhitneyu

# Teste de Normalidade
stat_tls, p_tls = shapiro(df_tls['Transfer(MB)'])
stat_ipsec, p_ipsec = shapiro(df_ipsec['Transfer(MB)'])

print(f'P-value do teste de normalidade para TLS: {p_tls}')
print(f'P-value do teste de normalidade para IPsec: {p_ipsec}')

# Escolha do Teste Estatístico
if p_tls > 0.05 and p_ipsec > 0.05:  # Se ambos os conjuntos de dados são normalmente distribuídos
    statistic, p_value = ttest_ind(df_tls['Transfer(MB)'], df_ipsec['Transfer(MB)'])
else:  # Se pelo menos um dos conjuntos de dados não é normalmente distribuído
    statistic, p_value = mannwhitneyu(df_tls['Transfer(MB)'], df_ipsec['Transfer(MB)'])

# Análise dos Resultados
alpha = 0.05
if p_value < alpha:
    print("Rejeitar H0: O TLS transmite mais dados que o IPsec.")
else:
    print("Não há evidências para rejeitar H0.")

# Teste de Normalidade
stat_tls, p_tls = shapiro(df_tls['Bitrate(MB)'])
stat_ipsec, p_ipsec = shapiro(df_ipsec['Bitrate(MB)'])

print(f'P-value do teste de normalidade para TLS: {p_tls}')
print(f'P-value do teste de normalidade para IPsec: {p_ipsec}')

# Escolha do Teste Estatístico
if p_tls > 0.05 and p_ipsec > 0.05:  # Se ambos os conjuntos de dados são normalmente distribuídos
    statistic, p_value = ttest_ind(df_tls['Bitrate(MB)'], df_ipsec['Bitrate(MB)'])
else:  # Se pelo menos um dos conjuntos de dados não é normalmente distribuído
    statistic, p_value = mannwhitneyu(df_tls['Bitrate(MB)'], df_ipsec['Bitrate(MB)'])

# Análise dos Resultados
alpha = 0.05
if p_value < alpha:
    print("Rejeitar H0: O IPsec é mais estável que o TLS.")
else:
    print("Não há evidências para rejeitar H0.")